<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Basic Bust-a-Move / Puzzle Bobble / Bubble Shooter</title>
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto; background:#0b0f12; color:#e7ecf0; display:grid; place-items:center; min-height:100dvh; }
  .wrap { width:min(520px,96vw); position:relative; padding:12px; }
  .card { background:#12171b; border:1px solid #1f2a32; border-radius:14px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
  .row { display:flex; align-items:center; justify-content:space-between; gap:12px; }
  .title { font-weight:800; font-size:20px; margin:0 0 8px; }
  .muted { color:#9aa7b1; font-size:14px; line-height:1.35; }
  button { appearance:none; border:0; background:#1dd979; color:#04130c; font-weight:700; padding:10px 16px; border-radius:12px; cursor:pointer; }
  button:disabled { opacity:.6; cursor:not-allowed; }

  canvas {
    display:block;
    width:min(480px,96vw); height:auto;
    background:#0e1418; border:1px solid #1f2a32; border-radius:12px; margin:12px auto 10px;
    touch-action:none;
  }

  .hud { display:flex; justify-content:space-between; gap:8px; font-size:14px; color:#a8b6c1; }
  .kbd { background:#0f151a;border:1px solid #1f2a32;border-radius:8px;padding:2px 6px; }

  .overlay { position:fixed; inset:0; display:grid; place-items:center; background:rgba(8,11,14,.6); backdrop-filter:blur(2px); padding:16px; }
  .hidden { display:none!important; }
  #play-again, #play-start { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); padding:12px 18px; border-radius:12px; border:0; font-weight:700; background:#1dd979; color:#04130c; cursor:pointer; box-shadow:0 10px 30px rgba(0,0,0,.35); }

  #status { margin-top:10px; font-size:13px; line-height:1.35; background:#0f151a; border:1px solid #1f2a32; border-radius:10px; padding:10px; }
  #status b { color:#cde7d8; }
  #status .ok { color:#4ade80; }
  #status .warn { color:#fbbf24; }
  #status .err { color:#f87171; }
  #status a { color:#86c6ff; text-decoration:none; }

  /* Mobile controls */
  #mobile-controls { display:none; margin:6px auto 0; user-select:none; }
  #mobile-controls .ctrl {
    width:64px; height:64px; font-size:18px; font-weight:800;
    background:#1dd979; color:#04130c; border-radius:12px; border:0; cursor:pointer;
    box-shadow:0 3px 8px rgba(0,0,0,.3);
  }
  #mobile-controls .row { display:flex; justify-content:center; gap:10px; }
  @media (max-width:720px) {
    #mobile-controls { display:block; }
    .hud { font-size:12px; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div id="intro-overlay" class="overlay">
      <div class="card" role="dialog" aria-modal="true">
        <h1 class="title">Puzzle Bobble</h1>
        <p class="muted">A small Base payment is required to start playing.</p>
        <div class="row">
          <div class="muted">Change recipient/amount in code.</div>
          <button id="play-start" type="button">Pay & Play</button>
        </div>
        <div id="status" class="hidden"></div>
      </div>
    </div>

    <canvas width="271" height="392" id="game" aria-label="Puzzle Bobble game area"></canvas>

    <!-- On-screen mobile controls -->
    <div id="mobile-controls" class="hidden" aria-label="Mobile controls">
      <div class="row" style="margin-top:2px;">
        <button class="ctrl" data-dir="left"  aria-label="Aim left">←</button>
        <button class="ctrl" data-dir="shoot" aria-label="Shoot">●</button>
        <button class="ctrl" data-dir="right" aria-label="Aim right">→</button>
      </div>
    </div>

    <div class="hud">
      <div>Controls: <span class="kbd">←</span> <span class="kbd">→</span> &nbsp;/&nbsp; <span class="kbd">Space</span></div>
      <div class="muted">Dark UI shell — pay to start, and again if you lose.</div>
    </div>
  </div>

<script>
// === BEGIN: GAME CODE (running after payment) ===
// Global flag toggled by pay/start
window.GAME_ACTIVE = false;

function startGame() {
  window.GAME_ACTIVE = true;
  const overlay = document.getElementById('intro-overlay');
  overlay.classList.add('hidden');
  const titleEl = overlay.querySelector('.title');
  if (titleEl) titleEl.textContent = 'Puzzle Bobble';
  const btn = document.getElementById('play-start');
  if (btn) btn.textContent = 'Pay & Play';
  const statusEl = document.getElementById('status');
  if (statusEl) statusEl.classList.add('hidden');

  // show mobile controls on small screens
  const mobileCtrl = document.getElementById('mobile-controls');
  if (mobileCtrl && window.innerWidth <= 720) mobileCtrl.classList.remove('hidden');

  initGame();
}

function initGame() {
  const canvas = document.getElementById('game');
  const context = canvas.getContext('2d');

  // === ORIGINAL PUZZLE BOBBLE LOGIC (unchanged visuals/physics) ===
  const grid = 32;
  const level1 = [
    ['R','R','Y','Y','B','B','G','G'],
    ['R','R','Y','Y','B','B','G'],
    ['B','B','G','G','R','R','Y','Y'],
    ['B','G','G','R','R','Y','Y']
  ];
  const colorMap = { 'R':'red','G':'green','B':'blue','Y':'yellow' };
  const colors = Object.values(colorMap);
  const bubbleGap = 1;
  const wallSize = 4;
  const bubbles = [];
  let particles = [];

  let GAME_OVER = false; // block input/loop when true
  let lastMatchCount = 0;

  // track listeners for cleanup
  let keydownHandler = null;
  let keyupHandler = null;
  let touchRemover = null;
  let btnRemovers = [];

  function degToRad(deg){ return (deg*Math.PI)/180; }
  function rotatePoint(x,y,a){ const s=Math.sin(a), c=Math.cos(a); return { x:x*c - y*s, y:x*s + y*c }; }
  function getRandomInt(min,max){ min=Math.ceil(min); max=Math.floor(max); return Math.floor(Math.random()*(max-min+1))+min; }
  function getDistance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function collides(a,b){ return getDistance(a,b) < a.radius + b.radius; }

  function getClosestBubble(obj, activeState=false){
    const close = bubbles.filter(b => b.active==activeState && collides(obj,b));
    if (!close.length) return;
    return close.map(b=>({ distance:getDistance(obj,b), bubble:b }))
                .sort((a,b)=>a.distance-b.distance)[0].bubble;
  }

  function createBubble(x,y,color){
    const row = Math.floor(y/grid);
    const col = Math.floor(x/grid);
    const startX = row % 2 === 0 ? 0 : 0.5 * grid;
    const center = grid / 2;
    bubbles.push({
      x: wallSize + (grid + bubbleGap) * col + startX + center,
      y: wallSize + (grid + bubbleGap - 4) * row + center,
      radius: grid/2,
      color: color,
      active: !!color
    });
  }

  function getNeighbors(bubble){
    const neighbors=[];
    const dirs=[
      rotatePoint(grid,0,0),
      rotatePoint(grid,0,degToRad(60)),
      rotatePoint(grid,0,degToRad(120)),
      rotatePoint(grid,0,degToRad(180)),
      rotatePoint(grid,0,degToRad(240)),
      rotatePoint(grid,0,degToRad(300))
    ];
    for (let i=0;i<dirs.length;i++){
      const dir = dirs[i];
      const probe = { x:bubble.x+dir.x, y:bubble.y+dir.y, radius:bubble.radius };
      const n = getClosestBubble(probe,true);
      if (n && n!==bubble && !neighbors.includes(n)) neighbors.push(n);
    }
    return neighbors;
  }

  function removeMatch(targetBubble){
    const matches=[targetBubble];
    bubbles.forEach(b=>b.processed=false);
    targetBubble.processed=true;
    let neighbors=getNeighbors(targetBubble);
    for (let i=0;i<neighbors.length;i++){
      const n=neighbors[i];
      if (!n.processed){
        n.processed=true;
        if (n.color===targetBubble.color){
          matches.push(n);
          neighbors = neighbors.concat(getNeighbors(n));
        }
      }
    }
    lastMatchCount = matches.length;
    if (matches.length>=3){ matches.forEach(b=>b.active=false); return true; }
    return false;
  }

  function dropFloatingBubbles(){
    const active = bubbles.filter(b=>b.active);
    active.forEach(b=>b.processed=false);
    let neighbors = active.filter(b=> b.y - grid <= wallSize);
    for (let i=0;i<neighbors.length;i++){
      const n=neighbors[i];
      if (!n.processed){ n.processed=true; neighbors = neighbors.concat(getNeighbors(n)); }
    }
    active.filter(b=>!b.processed).forEach(b=>{
      b.active=false; particles.push({ x:b.x, y:b.y, color:b.color, radius:b.radius, active:true });
    });
  }

  for (let row=0; row<10; row++){
    for (let col=0; col<(row%2===0?8:7); col++){
      const color = level1[row]?.[col];
      createBubble(col*grid, row*grid, colorMap[color]);
    }
  }

  const curBubblePos = { x: canvas.width/2, y: canvas.height - grid*1.5 };
  const curBubble = { x:curBubblePos.x, y:curBubblePos.y, color:'red', radius:grid/2, speed:8, dx:0, dy:0 };
  let shootDeg = 0;
  const minDeg = degToRad(-60), maxDeg = degToRad(60);
  let shootDir = 0;

  function getNewBubble(){
    curBubble.x = curBubblePos.x; curBubble.y = curBubblePos.y; curBubble.dx = curBubble.dy = 0;
    const rand = getRandomInt(0, colors.length-1); curBubble.color = colors[rand];
  }

  function handleCollision(bubble){
    bubble.color = curBubble.color;
    bubble.active = true;
    getNewBubble();
    const didMatch = removeMatch(bubble);
    dropFloatingBubbles();
    if (!didMatch){
      // shot placed without a match: lose & pay again
      gameOver();
    }
  }

  function gameOver(){
    GAME_OVER = true;
    window.GAME_ACTIVE = false;
    // hide mobile controls
    const mobileCtrl = document.getElementById('mobile-controls');
    if (mobileCtrl) mobileCtrl.classList.add('hidden');
    // remove listeners
    if (keydownHandler) window.removeEventListener('keydown', keydownHandler);
    if (keyupHandler) window.removeEventListener('keyup', keyupHandler);
    if (touchRemover) touchRemover();
    btnRemovers.forEach(off=>off()); btnRemovers = [];

    // show overlay asking to pay again
    const overlay = document.getElementById('intro-overlay');
    const titleEl = overlay.querySelector('.title');
    if (titleEl) titleEl.textContent = 'Game Over';
    const btn = document.getElementById('play-start');
    if (btn) btn.textContent = 'Pay & Play Again';
    const statusEl = document.getElementById('status');
    if (statusEl) statusEl.classList.add('hidden');
    overlay.classList.remove('hidden');
  }

  function loop(){
    if (GAME_OVER) return;
    requestAnimationFrame(loop);
    context.clearRect(0,0,canvas.width,canvas.height);

    // move the shooting arrow
    shootDeg = shootDeg + degToRad(2) * shootDir;
    if (shootDeg < minDeg) shootDeg = minDeg; else if (shootDeg > maxDeg) shootDeg = maxDeg;

    // move current bubble by velocity
    curBubble.x += curBubble.dx; curBubble.y += curBubble.dy;

    // walls bounce
    if (curBubble.x - grid/2 < wallSize){ curBubble.x = wallSize + grid/2; curBubble.dx *= -1; }
    else if (curBubble.x + grid/2 > canvas.width - wallSize){ curBubble.x = canvas.width - wallSize - grid/2; curBubble.dx *= -1; }

    // top collision
    if (curBubble.y - grid/2 < wallSize){ const closest = getClosestBubble(curBubble); handleCollision(closest); }

    // bubble collision
    for (let i=0;i<bubbles.length;i++){
      const b = bubbles[i];
      if (b.active && collides(curBubble,b)){
        const closest = getClosestBubble(curBubble);
        if (!closest){ alert('Game Over'); window.location.reload(); }
        if (closest) handleCollision(closest);
      }
    }

    // particles
    particles.forEach(p=> p.y += 8);
    particles = particles.filter(p=> p.y < canvas.height - grid/2);

    // walls
    context.fillStyle='lightgrey';
    context.fillRect(0,0,canvas.width,wallSize);
    context.fillRect(0,0,wallSize,canvas.height);
    context.fillRect(canvas.width-wallSize,0,wallSize,canvas.height);

    // bubbles & particles
    bubbles.concat(particles).forEach(b=>{
      if (!b.active) return; context.fillStyle=b.color; context.beginPath(); context.arc(b.x,b.y,b.radius,0,2*Math.PI); context.fill();
    });

    // arrow
    context.save();
    context.translate(curBubblePos.x, curBubblePos.y); context.rotate(shootDeg); context.translate(0,-grid/2*4.5);
    context.strokeStyle='white'; context.lineWidth=2; context.beginPath();
    context.moveTo(0,0); context.lineTo(0, grid*2);
    context.moveTo(0,0); context.lineTo(-10, grid*0.4);
    context.moveTo(0,0); context.lineTo(10, grid*0.4);
    context.stroke();
    context.restore();

    // current bubble
    context.fillStyle = curBubble.color; context.beginPath(); context.arc(curBubble.x, curBubble.y, curBubble.radius, 0, 2*Math.PI); context.fill();
  }

  // --- keyboard (desktop) ---
  keydownHandler = (e)=>{
    if (GAME_OVER) return;
    if (e.code==='ArrowLeft') shootDir=-1; else if (e.code==='ArrowRight') shootDir=1;
    if (e.code==='Space' && curBubble.dx===0 && curBubble.dy===0){ curBubble.dx = Math.sin(shootDeg)*curBubble.speed; curBubble.dy = -Math.cos(shootDeg)*curBubble.speed; }
  };
  keyupHandler = (e)=>{ if ((e.code==='ArrowLeft' && shootDir===-1) || (e.code==='ArrowRight' && shootDir===1)) shootDir=0; };
  window.addEventListener('keydown', keydownHandler);
  window.addEventListener('keyup', keyupHandler);

  // --- mobile buttons ---
  const mobileCtrl = document.getElementById('mobile-controls');
  if (mobileCtrl && window.innerWidth <= 720) {
    const leftBtn = mobileCtrl.querySelector('button[data-dir="left"]');
    const rightBtn = mobileCtrl.querySelector('button[data-dir="right"]');
    const shootBtn = mobileCtrl.querySelector('button[data-dir="shoot"]');

    const onDown = (dir)=>{ if (GAME_OVER) return; shootDir = dir; };
    const onUp = ()=>{ if (GAME_OVER) return; shootDir = 0; };

    const bindHold = (btn, dir)=>{
      const down = ()=>onDown(dir);
      const up = ()=>onUp();
      btn.addEventListener('pointerdown', down);
      btn.addEventListener('pointerup', up);
      btn.addEventListener('pointerleave', up);
      btn.addEventListener('pointercancel', up);
      btnRemovers.push(()=>{
        btn.removeEventListener('pointerdown', down);
        btn.removeEventListener('pointerup', up);
        btn.removeEventListener('pointerleave', up);
        btn.removeEventListener('pointercancel', up);
      });
    };

    if (leftBtn) bindHold(leftBtn, -1);
    if (rightBtn) bindHold(rightBtn, 1);
    if (shootBtn) {
      const click = ()=>{ if (GAME_OVER) return; if (curBubble.dx===0 && curBubble.dy===0){ curBubble.dx = Math.sin(shootDeg)*curBubble.speed; curBubble.dy = -Math.cos(shootDeg)*curBubble.speed; } };
      shootBtn.addEventListener('click', click);
      btnRemovers.push(()=> shootBtn.removeEventListener('click', click));
    }
  }

  // --- swipe to aim, tap to shoot ---
  touchRemover = (function setupSwipe(){
    let sx=0, sy=0, tracking=false;
    const onStart = (e)=>{ const t=e.touches[0]; sx=t.clientX; sy=t.clientY; tracking=true; };
    const onMove  = (e)=>{ if (tracking) e.preventDefault(); };
    const onEnd   = (e)=>{
      if (!tracking) return; tracking=false;
      const t=e.changedTouches[0]; const dx=t.clientX-sx; const dy=t.clientY-sy;
      const ax=Math.abs(dx), ay=Math.abs(dy);
      if (Math.max(ax,ay) < 25){
        // tap: shoot
        if (curBubble.dx===0 && curBubble.dy===0){ curBubble.dx = Math.sin(shootDeg)*curBubble.speed; curBubble.dy = -Math.cos(shootDeg)*curBubble.speed; }
        return;
      }
      // horizontal swipe: nudge aim direction briefly
      if (ax>ay){
        shootDir = dx>0 ? 1 : -1;
        setTimeout(()=>{ shootDir = 0; }, 160);
      }
    };
    canvas.addEventListener('touchstart', onStart, { passive:true });
    canvas.addEventListener('touchmove',  onMove,  { passive:false });
    canvas.addEventListener('touchend',   onEnd,   { passive:true });
    return ()=>{
      canvas.removeEventListener('touchstart', onStart);
      canvas.removeEventListener('touchmove',  onMove);
      canvas.removeEventListener('touchend',   onEnd);
    };
  })();

  // start loop
  requestAnimationFrame(loop);
}
// === END: GAME CODE ===
</script>

<script type="module">
  import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
  sdk.actions.ready();

  /* ===== CONFIG ===== */
  const USE_BASE_SEPOLIA = false;     // true: 84532, false: 8453 (your current choice)
  const RECIPIENT = "0x02212a875c56baE7AF27A5a389FD4e8A11442692";
  const AMOUNT_ETH = "0.00001";

  const BASE_MAINNET = { chainId: "0x2105",  explorer: "https://basescan.org/tx/" };
  const BASE_SEPOLIA = { chainId: "0x14a34", explorer: "https://sepolia.basescan.org/tx/" };
  const TARGET = USE_BASE_SEPOLIA ? BASE_SEPOLIA : BASE_MAINNET;

  /* ===== PAYMENT + UI ===== */
  const statusEl = document.getElementById('status');
  const playStartBtn = document.getElementById('play-start');

  function parseEther(x){
    const [w,f=""]=String(x).split('.');
    const frac=(f+'0'.repeat(18)).slice(0,18);
    return '0x'+(BigInt(w)*10n**18n+BigInt(frac)).toString(16);
  }
  async function getProvider(){
    try { const p = await sdk.wallet.getEthereumProvider(); if (p) return p; } catch {}
    return window.ethereum ?? null;
  }
  async function ensureChain(provider, chainId) {
    const current = (await provider.request({ method:'eth_chainId' }))?.toLowerCase();
    if (current === chainId.toLowerCase()) return;
    try {
      await provider.request({ method:'wallet_switchEthereumChain', params:[{ chainId }] });
    } catch (e) {
      if (e?.code === 4902) {
        await provider.request({ method:'wallet_addEthereumChain', params:[{ chainId }] });
        await provider.request({ method:'wallet_switchEthereumChain', params:[{ chainId }] });
      } else { throw e; }
    }
  }

  async function requiredPayment() {
    statusEl.classList.remove('hidden');
    statusEl.innerHTML = '<b>Connecting wallet…</b>';
    const provider = await getProvider();
    if (!provider) { statusEl.innerHTML += '<div class="err">No wallet available.</div>'; throw new Error('NO_PROVIDER'); }
    const [from] = await provider.request({ method:'eth_requestAccounts' });
    await ensureChain(provider, TARGET.chainId);
    statusEl.innerHTML += `<div>Sending ${AMOUNT_ETH} ETH to ${RECIPIENT.slice(0,6)}…${RECIPIENT.slice(-4)}…</div>`;
    const hash = await provider.request({ method:'eth_sendTransaction', params:[{ from, to: RECIPIENT, value: parseEther(AMOUNT_ETH) }] });
    statusEl.innerHTML += `<div class="ok">TX sent! <a target="_blank" href="${TARGET.explorer}${hash}">View TX</a></div>`;
    return hash;
  }

  async function payThenStart(btn) {
    try {
      btn.disabled = true;
      await requiredPayment();
      // If the game is already active (after a loss), reload for a clean state
      if (window.GAME_ACTIVE) {
        window.location.reload();
      } else {
        startGame();
      }
    } catch (e) {
      statusEl.innerHTML += `<div class="warn">Payment failed or cancelled.</div>`;
    } finally {
      btn.disabled = false;
    }
  }

  playStartBtn.addEventListener('click', (e)=>{ e.preventDefault(); payThenStart(playStartBtn); });
</script>
</body>
</html>
